<!-- dcterms:identifier = aspnetcz#313 -->
<!-- dcterms:title = Reset zapomenutého hesla – jak to dělat správně? -->
<!-- dcterms:abstract = Ačkoliv existují i lepší varianty autentizace uživatelů, hesla stále bezpečně převažují. A uživatelé hesla rádi zapomínají a dobré systémy by s tím měly počítat a měly by tudíž umožnit se ztrátou hesla se nějakým způsobem vypořádat. A to pokud možno bezpečně a automatizovaně. Tento článek se zabývá způsoby, jak to lze udělat a vyhnout se přitom obvyklým problémům. -->
<!-- np9:categoryId = 2 -->
<!-- x4w:category = Bezpečnost -->
<!-- np9:authorId = 1 -->
<!-- np9:authorEmail = michal.valasek@altairis.cz -->
<!-- dcterms:creator = Michal Altair Valášek -->
<!-- dcterms:created = 2011-01-03T00:10:36.78+01:00 -->
<!-- dcterms:dateSubmitted = 2011-01-03T00:17:17.857+01:00 -->
<!-- dcterms:date = 2011-01-03T05:27:27+01:00 -->
<!-- x4w:pictureWidth = 150 -->
<!-- x4w:pictureHeight = 150 -->
<!-- x4w:pictureUrl = /perex-pictures/20110103-reset-zapomenuteho-hesla-jak-to-delat-spravne.png -->

<p>Ačkoliv existují i lepší varianty autentizace uživatelů, hesla stále bezpečně převažují. A uživatelé hesla rádi zapomínají a dobré systémy by s tím měly počítat a měly by tudíž umožnit se ztrátou hesla se nějakým způsobem vypořádat. A to pokud možno bezpečně a automatizovaně. Zdálo by se, že tento úkol je tak jednoduchý, že na něm není co zkazit. Praktická zkušenost z různých webů mne ale přesvědčuje, že realita je bohužel odlišná.</p>  <p>Tento článek se zabývá běžnými internetovými systémy, které mají mnoho víceméně anonymních uživatelů a nespravují data, která by byla z hlediska bezpečnosti extrémně kritická. Jiná bude situace např. v případě, že zapomenete heslo k internetovému bankovnictví a nebo do systému v rámci firemní sítě. V prvním případě je z bezpečnostního hlediska vyloženě žádoucí, aby byla pro reset hesla nutná osobní návštěva pobočky nebo jiné velmi solidní prokázání totožnosti. Ve druhém případě zase patrně existují interní mechanismy, jakými se to řeší.</p>  <p>Základními parametry kvalitního resetu hesla by měla být jednoduchost pro uživatele, jednoduchost implementace provozovatelem a rozumná míra bezpečnosti. Reset hesla přitom sestává ze dvou kroků, přičemž v každém z nich je možné udělat chybu: ověření totožnosti žadatele a vlastní zpracování požadavku.</p>  <h2>Ověření totožnosti uživatele</h2>  <p>Prvním krokem je nezbytnost nějak si ověřit, že osoba žádající o reset hesla je skutečně oprávněná tak učinit. Existují v zásadě dva mechanismy, které lze obecně použít.</p>  <p>První je <strong>mechanismus kontrolní otázky</strong>, který je např. vestavěný (jako volitelný) v systému Membership providerů v ASP.NET. Při registraci uživatel kromě hesla vyplňuje také kontrolní otázku a odpověď na ni. Pro bezpečnost celého systému je kritické, nakolik bude správně zvolena bezpečnostní otázka a její odpověď. Pokud necháme volbu otázky na uživateli, je dost pravděpodobné, že většina otázek bude buďto triviálních a nebo nesmyslných, protože uživatelům se často nechce přemýšlet. Proto řada provozovatelů neumožňuje otázku určit zcela volně, ale ze seznamu předdefinovaných možností. Bohužel, ty jsou většinou dost tragické.</p>  <p>Téměř typickou je otázka na matčino křestní jméno za svobodna. Pominu teď rovinu, že by mohla být pokládána za genderově nekorektní, protože implicitně předpokládá, že matka byla vdaná a že přejala jméno svého manžela. Problémů je i tak dost. Možná jsem výjimka, ale já skutečně <em>nevím</em>, jak se moje matka jmenovala za svobodna. Asi bych to dokázal nějak dohledat, ale fakt to nevím, mám dost vágní představu, ale ani nevím, jak se to píše. Tento údaj je také poměrně snadno zjistitelný pomocí rozličných metod sociálního inženýrství. Kromě toho, dneska je na Internetu každý i jeho máma, takže dohledat jméno za svobodna není nijak nepřekonatelný problém. Tudy ne.</p>  <p>Další časté otázky jsou třeba &quot;oblíbená barva&quot;. Pravděpodobnost úspěšného útoku letmým odhadem značná, pokud tedy vaše oblíbená barva není třeba starorůžová. To samé pokud se týče dotazů na oblíbené sportovní týmy a podobně. Dotazy typu &quot;jméno prvního psa&quot; jsou opět v době Facebooku a blogů, kde na sebe vykecáme všechno, také bezcenné. Ostatně, v tom podle mého názoru spočívá údajná &quot;nebezpečnost&quot; Facebooku – ne v prozrazení údajů samých, ale v jejich zneužití v systémech, kteté je pokládají za příliš soukromé.</p>  <p>Obecně mechanismus kontrolní otázky pokládám za velmi problematický, protože má-li být skutečně k něčemu, klade velké nároky na uživatele. A to je v otázkách bezpečnosti vždycky špatně. Navíc způsob, jakým je obvykle implementován, tedy výběr z několika špatně vybraných otázek, je vyloženě nebezpečný. I zodpovědný uživatel je nucen buďto poctivě odpovědět na pitomou otázku a nebo napsat jako odpověď nesmysl a připravit se tak o možnost resetu hesla.</p>  <p>Druhým možným mechanismem je využití <strong>e-mailové adresy</strong>. Vycházíme při něm z předpokladu, že pouze oprávněný uživatel má přístup k e-mailové schránce, kterou uvedl při registraci. Tento předpoklad sice nemusí být stoprocentně pravdivý, ale u běžných internetových služeb zpravidla žádný lepší nemáme. Na e-mailovou adresu tedy pošleme heslo nebo nějaký kód, který umožní jeho reset.</p>  <h2>Vlastní zpracování požadavku</h2>  <p>Poté, co jsme si ověřili totožnost uživatele, je nezbytné se nějakým způsobem vypořádat se zapomenutým heslem. Existují v zásadě tři způsoby, jakými tak lze učinit.</p>  <p>První způsob je, že uživateli sdělíme (třeba pošleme e-mailem) jeho heslo. Tento způsob je nejméně vhodný, a to hned z několika důvodů. V první řadě znamená, že předmětný systém heslo uchovává v otevřeném formátu. Pokud by došlo k narušení jeho bezpečnosti, mohou hesla uživatelů v otevřeném tvaru uniknout. S výjimkou velmi speciálních případů (kdy jsou používány autentizační metody, které vyžadují znalost hesla v otevřeném tvaru) je takový postup velmi nevhodný, mnohem rozumnější je hesla uchovávat pouze ve formě hashů se solí. Zasílání hesel e-mailem je obecně velmi nevhodné, protože uživatelé mají tendence e-maily archivovat a hesla používat dlouhodobě a opakovaně. Vyzrazení, ke kterému může dojít snadno, může mít dalekosáhlé následky, protože ohrozí i ostatní účty uživatele v jiných systémech, které samy o sobě mohou být zabezpečeny dostatečně.</p>  <p>Druhý způsob spočívá v tom, že po obdržení žádosti o reset hesla systém vygeneruje náhodné heslo a to pošle e-mailem na registrovanou adresu. Tento postup je lepší v tom, že nevyzrazuje původní heslo, ale fakticky se může stát nástrojem pro obtěžování uživatele a nebo pro formu Denial of Service útoku. Pokud systém bude reagovat na žádost o reset hesla tím, že ho okamžitě změní, lze kterémukoliv uživateli znepřístupnit systém (nebo mu jeho použití minimálně znepříjemnit) prostě tím, že budu opakovaně automaticky posílat žádosti o reset hesla.</p>  <p>Nejvhodnější postup tedy spočívá v tom, že se heslo ve skutečnosti nezmění, ale e-mailem se pošle jenom kód, po jehož zadání bude uživatel moci nastavit heslo nové. Zpravidla se to realizuje tak, že se uživateli pošle odkaz &quot;tady na téhle adrese si můžete nastavit nové heslo&quot;, přičemž URL stránky obsahuje kód pro změnu hesla.</p>  <p>Tento kód by měl být generován dostatečně bezpečným způsobem, tedy nesmí být možné ho odhadnout nebo ovlivnit. Jeho platnost by také měla být omezená, aby nemohl být použit s přílišným časovým odstupem a nebo opakovaně. Jednou z možností je generovat kód náhodně a uchovávat jej v nějaké databázi. Mnohem elegantnější a na logistiku méně náročnou možností je použití mé oblíbené techniky HMAC – Hash Message Authentication Code, <a href="http://www.aspnet.cz/articles/146-hmac-hash-message-authentication-code">o níž jsem na ASPNET.CZ již psal před lety</a>.</p>  <h2>Sada extension methods pro generování kódu pro reset hesla</h2>  <p>Napsal jsem drobnou třídu, která bezpečný proces resetu hesla výrazně usnadňuje:</p>  <pre style="font-family: "><font face="Consolas"><span style="color: "><font color="#0000ff"><font style="font-size: 12pt">using</font></font></span><font style="font-size: 12pt"> System;<br><span style="color: "><font color="#0000ff">using</font></span> System.Configuration;<br><span style="color: "><font color="#0000ff">using</font></span> System.IO;<br><span style="color: "><font color="#0000ff">using</font></span> System.Web.Security;<br> <br><span style="color: "><font color="#0000ff">public</font></span>&#160;<span style="color: "><font color="#0000ff">static</font></span>&#160;<span style="color: "><font color="#0000ff">class</font></span>&#160;<span style="color: "><font color="#2b91af">ExtensionMethods</font></span> {<br> <br>&#160;&#160;&#160; <span style="color: "><font color="#0000ff">public</font></span>&#160;<span style="color: "><font color="#0000ff">static</font></span>&#160;<span style="color: "><font color="#0000ff">string</font></span> CreatePasswordResetCode(<span style="color: "><font color="#0000ff">this</font></span>&#160;<span style="color: "><font color="#2b91af">MembershipUser</font></span> user) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">if</font></span> (user == <span style="color: "><font color="#0000ff">null</font></span>) <span style="color: "><font color="#0000ff">throw</font></span>&#160;<span style="color: "><font color="#0000ff">new</font></span>&#160;<span style="color: "><font color="#2b91af">ArgumentNullException</font></span>(<span style="color: "><font color="#a31515">&quot;user&quot;</font></span>);<br> <br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#008000">// Prepare data to compute hash from (username + date)</font></span><br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">byte</font></span>[] data;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">using</font></span> (<span style="color: "><font color="#0000ff">var</font></span> ms = <span style="color: "><font color="#0000ff">new</font></span>&#160;<span style="color: "><font color="#2b91af">MemoryStream</font></span>()) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">using</font></span> (<span style="color: "><font color="#0000ff">var</font></span> bw = <span style="color: "><font color="#0000ff">new</font></span>&#160;<span style="color: "><font color="#2b91af">BinaryWriter</font></span>(ms)) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; bw.Write(user.UserName.ToLower());<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; bw.Write(<span style="color: "><font color="#2b91af">Math</font></span>.Max(user.LastActivityDate.ToBinary(), user.LastLoginDate.ToBinary()));<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; data = ms.ToArray();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br> <br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#008000">// Compute hash</font></span><br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">using</font></span> (<span style="color: "><font color="#0000ff">var</font></span> hmac = <span style="color: "><font color="#0000ff">new</font></span> System.Security.Cryptography.<span style="color: "><font color="#2b91af">HMACSHA1</font></span>()) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; hmac.Key = GetMacKey();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">var</font></span> hash = hmac.ComputeHash(data);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">return</font></span> hash.ToUrlSafeBase64String();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; }<br>&#160;&#160;&#160; }<br> <br>&#160;&#160;&#160; <span style="color: "><font color="#0000ff">public</font></span>&#160;<span style="color: "><font color="#0000ff">static</font></span>&#160;<span style="color: "><font color="#0000ff">bool</font></span> VerifyPasswordResetCode(<span style="color: "><font color="#0000ff">this</font></span>&#160;<span style="color: "><font color="#2b91af">MembershipUser</font></span> user, <span style="color: "><font color="#0000ff">string</font></span> code) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">if</font></span> (user == <span style="color: "><font color="#0000ff">null</font></span>) <span style="color: "><font color="#0000ff">throw</font></span>&#160;<span style="color: "><font color="#0000ff">new</font></span>&#160;<span style="color: "><font color="#2b91af">ArgumentNullException</font></span>(<span style="color: "><font color="#a31515">&quot;user&quot;</font></span>);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">if</font></span> (code == <span style="color: "><font color="#0000ff">null</font></span>) <span style="color: "><font color="#0000ff">throw</font></span>&#160;<span style="color: "><font color="#0000ff">new</font></span>&#160;<span style="color: "><font color="#2b91af">ArgumentNullException</font></span>(<span style="color: "><font color="#a31515">&quot;code&quot;</font></span>);<br> <br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">return</font></span> code.Equals(user.CreatePasswordResetCode(), <span style="color: "><font color="#2b91af">StringComparison</font></span>.Ordinal);<br>&#160;&#160;&#160; }<br> <br>&#160;&#160;&#160; <span style="color: "><font color="#0000ff">public</font></span>&#160;<span style="color: "><font color="#0000ff">static</font></span>&#160;<span style="color: "><font color="#0000ff">string</font></span> ToUrlSafeBase64String(<span style="color: "><font color="#0000ff">this</font></span>&#160;<span style="color: "><font color="#0000ff">byte</font></span>[] data) {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">var</font></span> s = <span style="color: "><font color="#2b91af">Convert</font></span>.ToBase64String(data);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; s = s.Replace(<span style="color: "><font color="#a31515">'+'</font></span>, <span style="color: "><font color="#a31515">'-'</font></span>);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; s = s.Replace(<span style="color: "><font color="#a31515">'/'</font></span>, <span style="color: "><font color="#a31515">'_'</font></span>);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; s = s.TrimEnd(<span style="color: "><font color="#a31515">'='</font></span>);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">return</font></span> s;<br>&#160;&#160;&#160; }<br> <br>&#160;&#160;&#160; <span style="color: "><font color="#008000">// Private helper methods</font></span><br> <br>&#160;&#160;&#160; <span style="color: "><font color="#0000ff">private</font></span>&#160;<span style="color: "><font color="#0000ff">static</font></span>&#160;<span style="color: "><font color="#0000ff">byte</font></span>[] GetMacKey() {<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: "><font color="#0000ff">return</font></span>&#160;<span style="color: "><font color="#2b91af">Convert</font></span>.FromBase64String(<span style="color: "><font color="#2b91af">ConfigurationManager</font></span>.AppSettings[<span style="color: "><font color="#a31515">&quot;PasswordResetKey&quot;</font></span>]);<br>&#160;&#160;&#160; }<br> <br>}</font></font><br></pre>

<p>Obsahuje čtyři metody:</p>

<ul>
  <li><strong>CreatePasswordResetCode</strong> je <a href="http://www.aspnet.cz/articles/177-extension-methods-v-c-3-0-k-cemu-jsou-dobre-a-jak-je-psat">extension metoda</a>, která&#160; rozšiřuje třídu <em>MembershipUser</em>. Vygeneruje string, který je založen na uživatelském jménu, datumu poslední aktivity a tajném klíči. Tento string je nutné zaslat uživateli e-mailem.</li>

  <li><strong>VerifyPasswordResetCode</strong> je další extension metoda, která rozšiřuje třídu MembershipUser. Ověří, zda je předaný string platný kód pro reset hesla (je triviální, jenom porovná předaný řetězec s tím, který vygeneruje předchozí třída).</li>

  <li><strong>ToUrlSafeBase64String</strong> je interně používaná metoda, která převede pole bajtů na URL-safe Base64. Běžné Base64 kódování převede libovolné pole bajtů na tisknutelné znaky. Base64 abeceda nicméně používá znaky &quot;+&quot; a &quot;/&quot;, které mají v URL speciální význam. Proto se běžně nahrazují znaky &quot;-&quot; a &quot;_&quot;, které jsou pro použití v rámci URL bezpečné. Base64 kódování také kóduje bajty &quot;po třech&quot; a pokud jich není správný počet, přidá na konec jeden nebo dva znaky &quot;=&quot; jako padding. Vzhledem k tomu, že hashe mají konstantní délku, můžeme v tomto případě tyto znaky z konce řetězce odstranit. Tato metoda se používá pro vytvoření kódu, může být ale užitečná i jinak, proto jsem ji zpřístupnil jako extension metodu pro pole bajtů.</li>

  <li><strong>GetMacKey</strong> je privátní metoda, která vrací soukromý klíč. To je jakákoliv náhodně vygenerovaná hromádka bajtů, která musí mít jenom dvě vlastnosti: nesmí být odhadnutelná a nesmí se mezi vygenerováním kódu a jeho ověřením změnit. Pro účely použití třídou HMACSHA1 může mít jakoukoliv délku, já osobně používám obvykle délku shodnou s délkou výsledného hashe (v tomto případě tedy 160 bitů). Typicky je takový klíč součástí konfigurace. V mém případě jsem pro ukládání použil kolekci <em>appSettings</em>, kam jsem uložil náhodně vygenerovanou hodnotu (k jejímu vytvoření můžete použít např. <a href="http://chaos.aspnet.cz/">ASP.NET Chaos Generator</a>).</li>
</ul>

<p>Použití této třídy je jednoduché. Na základě uživatelem zadaných údajů (typicky uživatelské jméno nebo e-mail) si z membership providera vytáhnete přes metodu <em>Membership.GetUser</em> instanci třídy <em>MembershipUser</em>, která reprezentuje daného uživatele. Na této instanci zavoláte extension metodu <em>CreatePasswordResetCode</em> a výsledný kód pošlete uživateli e-mailem. Na potvrzovací stránce opět získáte patřičného uživatele a ověříte si, že je kód správný, pomocí metody <em>VerifyPasswordResetCode</em>. Pokud ano, umožníte uživateli, aby nastavil nové heslo.</p>

<p>Kód pro změnu hesla je závislý na dvou neměnných údajích (tajný klíč a uživatelské jméno) a jednom proměnlivém. Tím je datum posledního použití účtu. Vybírám to větší (novější) datum z data poslední aktivity a data posledního přihlášení. Někteří membership provideři totiž datum poslední aktivity neaktualizují (třeba z výkonových důvodů). Použití datumu je nicméně důležité, protože zajistí, že kód se stane automaticky neplatným při prvním úspěšném přihlášení, tj. po změně hesla a nebo i pokud si uživatel mezitím na heslo vzpomněl a přihlásil se pod starým.</p>

<p>Trochu diskutabilní je ve výše uvedeném kódu použití SHA-1, tedy algoritmu, který je obecně pokládán za již mírně zastaralý. Bylo by snadné (a z bezpečnostního hlediska vhodnější) použít novější algoritmy z rodiny SHA-2, třeba SHA-256 nebo SHA-512. Ty by ale generovaly výrazně delší potvrzovací kódy, což by mohlo znamenat problémy při tvorbě potvrzovacího URL (problémy se zalomením řádků v e-mailových klientech a podobně). Vzhledem k tomu, že použití SHA-1 nepředstavuje bezprostřední hrozbu a tento scénář závislý na e-mailu se stejně nehodí pro &quot;high security&quot; aplikace, dal jsem přednost kratšímu hashi. Nicméně v případě potřeby je možné jenom zaměnit třídu <em>HMACSHA1</em> např. za <em>HMACSHA256</em>.</p>