<!-- dcterms:identifier = aspnetcz#177 -->
<!-- dcterms:title = Extension Methods v C# 3.0 - k čemu jsou dobré a jak je psát -->
<!-- dcterms:abstract = V C# 3.0 je dostupná nová technologie Extension Methods, která vám umožní přidat k nějaké třídě metodu, aniž byste museli zasahovat do třídy samé. Sama o sobě to není převratná záležitost, ale může zpřehlednit kód. -->
<!-- np9:categoryId = 1 -->
<!-- x4w:category = IT -->
<!-- np9:authorId = 1 -->
<!-- np9:authorEmail = michal.valasek@altairis.cz -->
<!-- dcterms:creator = Michal Altair Valášek -->
<!-- dcterms:created = 2007-12-14T10:30:48+01:00 -->
<!-- dcterms:date = 2007-12-14T10:30:48+01:00 -->

<p>V nejnovější verzi 3.0 jazyka C# (z důvodu zmatení nepřítele je součástí .NET Frameworku 3.5) je dostupná nová technologie <em>Extension Methods</em>. Extension methods vám umožňují přidat třídě instanční metodu &quot;zvenčí&quot;, aniž byste museli modifikovat třídu samotnou.</p> <h2>Jak to funguje</h2> <p>Vytváření extension methods je jednoduché. Stačí vytvořit statickou třídu a v ní vytvořit statickou metodu. První argument této metody jest třeba uvodit klíčovým slovem <code>this</code>.</p> <p>Jakmile toto uděláte, tak ve všech třídách, které předmětnou statickou třídu vidí (importují její namespace) můžete tuto metodu volat tak, jako by byla součástí třídy, která je jejím prvím parametrem.</p> <h2>Praktický příklad</h2> <p>Pokud vám předchozí dva odstavce nedávají smysl, nebojte se. Je to ve skutečnosti mnohem méně složité, než jak to vypadá.</p> <p>Poměrně často potřebuji převést jeden konkrétní sloupeček z <code>DataTable</code> do jednorozměrného pole stringů. Klasické řešení podobných případů spočívá v tom, že si vytvořím nějakou třídu jménem <code>Utils</code> nebo tak nějak, do které tuto funkcionalitu schovám - vytvořím jednorozměrné stringové pole a zkopíruju do něj obsah nultého sloupečku tabulky. Třídu pak používám tak, že napíšu něco jako <code>string[] pole = Utils.TableToArray(table);</code>.</p> <p>Extension methods nabízejí elegantnější řešení. Jeho zdrojový kód vypadá následovně:</p> <div style="font-size: 12pt; background: white; color: black; font-family: consolas, courier new"> <p style="margin: 0px"><span style="color: blue">using</span> System.Data;</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px"><span style="color: blue">namespace</span> Altairis.IdentityToolkit.UserMap {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">internal</span> <span style="color: blue">static</span> <span style="color: blue">class</span> <span style="color: #2b91af">ExtensionMethods</span> {</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: blue">string</span>[] ToStringArray(<span style="color: blue">this</span> <span style="color: #2b91af">DataTable</span> table, <span style="color: blue">int</span> columnIndex) {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span>[] data = <span style="color: blue">new</span> <span style="color: blue">string</span>[table.Rows.Count];</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">for</span> (<span style="color: blue">int</span> i = 0; i &lt; table.Rows.Count; i++) data[i] = System.<span style="color: #2b91af">Convert</span>.ToString(table.Rows[i][0]);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">return</span> data;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px">}</p></div> <p>Kouzelné slovíčko <code>this</code> před názvem první tabulky způsobí, že v jakékoliv třídě, která bude ve stejném namespace jako třída <code>ExtensionMethods</code>, nebo ho bude importovat, budu moci napsat něco jako:</p> <div style="font-size: 12pt; background: white; color: black; font-family: consolas, courier new"> <p style="margin: 0px"><span style="color: #2b91af">DataTable</span> dt = <span style="color: blue">new</span> <span style="color: #2b91af">DataTable</span>();</p> <p style="margin: 0px"><span style="color: green">// Tady dt nějak naplním, třeba pomocí SqlDataAdapteru</span></p> <p style="margin: 0px"><span style="color: blue">string</span>[] pole = dt.ToStringArray(0);</p></div> <p>Vše je samozřejmě strongly-typed, k dispozici je IntelliSense a podobné vymoženosti.</p> <p>Extension methods mohou být overloadované, případně mohou overloadovat již existující metody. Moje metoda <code>ToStringArray</code> tak má celkem tři overloady: pokud ji zavolám bez parametrů, převede na pole nultý sloupeček tabulky. Tento případ je nejčastější, dotazy tohoto typu většinou ostatně mívají jenom jeden sloupeček jako výsledek. Případně ji mohu zavolat s celočíselným parametrem, který značí index sloupce, který se má použít. Nebo ji mohu zavolat se stringovým parametrem, který značí název sloupce:</p> <div style="font-size: 12pt; background: white; color: black; font-family: consolas, courier new"> <p style="margin: 0px"><span style="color: blue">using</span> System.Data;</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px"><span style="color: blue">namespace</span> Altairis.IdentityToolkit.UserMap {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; <span style="color: blue">internal</span> <span style="color: blue">static</span> <span style="color: blue">class</span> <span style="color: #2b91af">ExtensionMethods</span> {</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: blue">string</span>[] ToStringArray(<span style="color: blue">this</span> <span style="color: #2b91af">DataTable</span> table) {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">return</span> ToStringArray(table, 0);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: blue">string</span>[] ToStringArray(<span style="color: blue">this</span> <span style="color: #2b91af">DataTable</span> table, <span style="color: blue">string</span> columnName) {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">return</span> ToStringArray(table, table.Columns[columnName].Ordinal);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: blue">string</span>[] ToStringArray(<span style="color: blue">this</span> <span style="color: #2b91af">DataTable</span> table, <span style="color: blue">int</span> columnIndex) {</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">string</span>[] data = <span style="color: blue">new</span> <span style="color: blue">string</span>[table.Rows.Count];</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">for</span> (<span style="color: blue">int</span> i = 0; i &lt; table.Rows.Count; i++) data[i] = System.<span style="color: #2b91af">Convert</span>.ToString(table.Rows[i][0]);</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue">return</span> data;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">&nbsp;&nbsp;&nbsp; }</p> <p style="margin: 0px">&nbsp;</p> <p style="margin: 0px">}</p></div> <h2>Filozofická odbočka</h2> <p>Extension methods v .NET Frameworku přibyly kvůli LINQu. Jeho elegantní konstrukce by bez nich nebyly možné. Můžete je ovšem využívat i bez něj. Samozřejmě, že se bez nich dokážete obejít. Nepřinášejí nic úplně převratného, jenom drobné ulehčení zápisu - syntaktický cukr.</p> <p>Se syntaktickým cukrem je to podobně, jako se skutečným kořením v reálném životě. Je nutné, aby ho bylo <em>přiměřené</em> množství. A <em>přiměřené</em> je subjektivní parametr, což jsem zjistil po půlročním soužití s člověkem, který do libovolného jídla bez ohledu na jeho povahu a původ nasype několik lžic soli, půl lahve kečupu a větší množství sojové omáčky.</p> <p>Pokud je syntaktického cukru málo, dokážete v daném programovacím jazyce (je-li <em>Turing complete</em>) napsat cokoliv, ale nebude to moc přehledné. Programovací jazyk může mít pouhých osm instrukcí - vzor elegance a stylové čistoty - leč pak bude populární aplikace <em>Hello World</em> vypadat třeba takto:</p> <div style="font-size: 12pt; background: white; color: black; font-family: consolas, courier new"> <p style="margin: 0px">++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;</p> <p style="margin: 0px">&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;++++++</p> <p style="margin: 0px">+++++++++.&gt;.+++.------.--------.&gt;+.&gt;.</p></div> <p>Na druhou stranu, pokud je syntaktického cukru příliš, podporuje to psaní příliš obskurních konstrukcí a vede ke vzniku <em>write-only</em> programovacích jazyků, kdy se v kódu vyzná jenom jeho autor, a to ještě jenom nepříliš dlouhou dobu poté, co ho napsal.</p> <p>Podle mého subjektivního názoru vděčí .NET za úspěch tomu, že v jeho kmenových jazycích je syntaktického cukru <em>tak akorát</em>.</p> <h2>Zpět k extension methods</h2> <p>Pár nesourodých postřehů, které se týkají extension methods a odpovídají na nabízející se otázky:</p> <ul> <li>Je jedno, jaká třída bude extension methods obsahovat, jak se bude jmenovat, jestli bude jedna pro všechny objekty nebo pro každou třídu jiná. Musí být jenom statická. Osobně to řeším tak, že v assembly od toho držím třídu jménem <code>ExtensionMethods</code>, ale to je věc osobního vkusu.</li> <li>Extension methods nelze vytvářet jako statické, jenom instanční.</li> <li>Neexistují žádné &quot;extension properties&quot; nebo &quot;extension events&quot;. Tímto způsobem lze definovat jen a pouze metody.</li></ul> <h2>Malá soutěž na závěr</h2> <p>Programovací jazyk o pouhých osmi instrukcích, který jsem o pár odstavců výše předvedl, je skutečný. Jeho kompilátor má 240 bajtů. První čtenář, který do komentářů napíše, jak se tento programovací jazyk jmenuje, kdo je jeho autorem a ve kterém roce vznikl, dostane za odměnu tričko.</p>